/// Macro to implement common enum utilities for repr(u8) enums.
///
/// This macro generates:
/// - COUNT: number of variants
/// - NAMES: array of variant names as strings
/// - VARIANTS: array of all variants
/// - from_u8: safe conversion from u8
/// - from_u8_unchecked: unsafe conversion from u8
///
/// Note: from_str_opt is NOT generated by this macro to allow custom implementations.
/// Use impl_from_str_opt! macro for the default implementation.
///
/// # Safety
/// This macro assumes the enum has a #[repr(u8)] attribute and variants numbered
/// sequentially from 0. The unsafe transmute is only used within bounds-checked code.
///
/// # Example
/// ```ignore
/// #[repr(u8)]
/// enum MyEnum {
///     Variant1,
///     Variant2,
/// }
///
/// impl MyEnum {
///     impl_enum_utils!(MyEnum, 2, Variant1);
///     impl_from_str_opt!();
///
///     pub const fn to_str(self) -> &'static str {
///         match self {
///             MyEnum::Variant1 => "Variant1",
///             MyEnum::Variant2 => "Variant2",
///         }
///     }
/// }
/// ```
#[macro_export]
macro_rules! impl_enum_utils {
    ($enum_type:ty, $count:expr, $default_variant:expr) => {
        /// Number of variants in this enum
        pub const COUNT: usize = $count;

        /// Array of all variant names as strings
        pub const NAMES: [&'static str; Self::COUNT] = {
            let mut i = 0;
            let mut names = [""; Self::COUNT];
            while i < Self::COUNT {
                names[i] = Self::VARIANTS[i].to_str();
                i += 1;
            }
            names
        };

        /// Array of all enum variants
        pub const VARIANTS: [$enum_type; Self::COUNT] = {
            let mut i = 0;
            let mut variants = [$default_variant; Self::COUNT];
            while i < Self::COUNT {
                variants[i] = unsafe { Self::from_u8_unchecked(i as u8) };
                i += 1;
            }
            variants
        };

        /// Convert from u8 to enum variant, returning None if out of bounds.
        ///
        /// # Safety
        /// This function uses unsafe transmute internally, but is safe because
        /// it checks bounds before transmuting.
        pub const fn from_u8(value: u8) -> Option<Self> {
            if Self::COUNT > value as usize {
                Some(unsafe { Self::from_u8_unchecked(value) })
            } else {
                None
            }
        }

        /// Convert from u8 to enum variant without bounds checking.
        ///
        /// # Safety
        /// The caller must ensure that `value` is less than COUNT.
        /// This function uses transmute to convert the u8 to the enum type,
        /// which is only valid for repr(u8) enums with sequential discriminants.
        const unsafe fn from_u8_unchecked(value: u8) -> Self {
            // SAFETY: Caller must ensure value is valid for this enum type
            unsafe { std::mem::transmute(value) }
        }
    };
}

/// Macro to implement the default from_str_opt method.
///
/// This provides case-insensitive string parsing by iterating through VARIANTS.
/// Types that need custom behavior (like ClientType) can skip this macro and
/// implement from_str_opt manually.
#[macro_export]
macro_rules! impl_from_str_opt {
    () => {
        /// Parse a string into the enum variant (case-insensitive).
        ///
        /// Returns None if the string doesn't match any variant name.
        fn from_str_opt(s: &str) -> Option<Self> {
            Self::VARIANTS
                .iter()
                .find(|v| v.to_str().eq_ignore_ascii_case(s))
                .copied()
        }
    };
}

/// Macro to implement error type for unknown enum variants.
///
/// This macro generates an error type and Display implementation that shows
/// all valid variant names.
///
/// # Example
/// ```ignore
/// impl_unknown_error!(UnknownMyEnumError, MyEnum, "my enum");
/// ```
#[macro_export]
macro_rules! impl_unknown_error {
    ($error_type:ident, $enum_type:ident, $type_name:expr) => {
        #[cfg_attr(test, derive(PartialEq, Eq))]
        #[derive(Debug)]
        pub struct $error_type(String);

        impl std::fmt::Display for $error_type {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "unknown {} `{}`, expected one of ", $type_name, self.0)?;
                let mut iter = $enum_type::NAMES.iter();
                if let Some(name) = iter.next() {
                    write!(f, "`{name}`")?;
                    for v in iter {
                        write!(f, ", `{v}`")?;
                    }
                }
                Ok(())
            }
        }

        impl std::error::Error for $error_type {}
    };
}

/// Macro to implement FromStr trait using from_str_opt.
///
/// # Example
/// ```ignore
/// impl_from_str!(MyEnum, UnknownMyEnumError);
/// ```
#[macro_export]
macro_rules! impl_from_str {
    ($enum_type:ty, $error_type:ident) => {
        impl std::str::FromStr for $enum_type {
            type Err = $error_type;

            fn from_str(s: &str) -> Result<Self, Self::Err> {
                Self::from_str_opt(s).ok_or_else(|| $error_type(s.to_owned()))
            }
        }
    };
}

/// Macro to implement serde Deserialize for enums.
///
/// # Example
/// ```ignore
/// impl_serde_deserialize!(MyEnum, "a valid my enum");
/// ```
#[cfg(feature = "serde")]
#[macro_export]
macro_rules! impl_serde_deserialize {
    ($enum_type:ident, $expecting:expr) => {
        impl<'de> serde::Deserialize<'de> for $enum_type {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                struct EnumVisitor;

                impl serde::de::Visitor<'_> for EnumVisitor {
                    type Value = $enum_type;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str($expecting)
                    }

                    fn visit_str<E: serde::de::Error>(self, value: &str) -> Result<Self::Value, E> {
                        $enum_type::from_str_opt(value)
                            .ok_or_else(|| E::unknown_variant(value, &$enum_type::NAMES))
                    }
                }

                deserializer.deserialize_str(EnumVisitor)
            }
        }
    };
}

/// Macro to implement serde Serialize for enums.
///
/// # Example
/// ```ignore
/// impl_serde_serialize!(MyEnum);
/// ```
#[cfg(feature = "serde")]
#[macro_export]
macro_rules! impl_serde_serialize {
    ($enum_type:ident) => {
        impl serde::Serialize for $enum_type {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.serialize_str(self.to_str())
            }
        }
    };
}

/// Macro to implement Debug and Display traits for enums.
///
/// # Example
/// ```ignore
/// impl_debug_display!(MyEnum);
/// ```
#[macro_export]
macro_rules! impl_debug_display {
    ($enum_type:ident) => {
        impl std::fmt::Debug for $enum_type {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_str(self.to_str())
            }
        }

        impl std::fmt::Display for $enum_type {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_str(self.to_str())
            }
        }
    };
}
